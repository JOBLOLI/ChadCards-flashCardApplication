    const collectionFlashCards = [
        { question: "Q1 what is a hashset, how is it different from a list", answer: "a collection that stores unique elements in no particular order. different because the elements must be unique."},
        { question: "Q2 what is a treeset", answer: "a collection that stores unique element in order backed by a tree"},
        { question: "Q3 what is a hashmap", answer: "a collection that stores key value pairs in no particular order. keys must be unique but values can be plagiarized"},
        { question: "Q4 what is a treemap", answer: "a collection that stores key value pairs in order backed by a tree. keys must be unique but values can be plagiarized"},
        { question: "Q5 what are iterators", answer: "An Iterator provides sequential access to a collection without exposing its structure"},
        { question: "Q6 name some of the most common Map methods", answer: "get, put, remove, keySet, size, values"},
        { question: "Q7 what is java Collection Framework", answer: "a set of interfaces (List, Set, Map, Queue) and their classes to implement interfaces (ArrayList, HashSet, HashMap, LinkedList)"},
        { question: "Q8 difference between Array and ArrayList", answer: "resizable for ArrayList"},
        { question: "Q9 advantage and disadvantage of ArrayList", answer: "noice: resizable and easy access to elements with indexes. not noice: storing and popping element as they need to shift position"},
        { question: "Q10 advantage and disadvantage of LinkedList", answer: "advantage: easy insert and delete. disadvantage: no random access and slow to access nth element O(n)"},
        { question: "Q11 binary search time complexity and explanation", answer: "O(log n) pretty fast. half of the array is eliminated after each step, works on sorted arrays"},
        { question: "Q12 interpolation search time complexity and explanation", answer: "average case of O(log log n) but can go up to O(n) it's like binary search but with guesses with a formula to find the probe"},
        { question: "Q13 bubble sort time complexity and explanation", answer: "O(n^2) slow AF. okay for smaller data sets. compares each adjacent element and switch if not in order"},
        { question: "Q14 merge sort time complexity and explanation", answer: "O(n log n) faster than most sorts a bit slower than O(n). breaks down big dataset into smaller ones until they have 1 element then merge them back together. disadvantage is that they use a lot of space"},
        { question: "not a question.. some examples of O notation... O(1): random access in array, inserting on Linkedlist. O(log n): binary search. O(n): search in LinkedList. O(n log n): quicksort, mergesort, heapsort. O(n^2): insertion sort, selection sort, bubble sort. O(n!): traveling salesman problem", answer: "tonka gigachad"},

        // ...more questions and answers here
    ];
